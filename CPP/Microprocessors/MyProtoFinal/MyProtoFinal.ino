
#define NUM_ROWS 7
#define NUM_COLS 5
#define ROW_DELAY 3

#include "ledfonts_5x7.h"

//These are the pins I will use to drive the rows of the 5X7 LED array
//They are listed in the array from the top row down
byte row_array[] = {A0,A1,A2,A3,A4,A5,7};
//These are the pins I will use to drive the columns of the 5X7 LED array
//They are listed in the array from the left-most column to the right
byte col_array[] = {8,3,4,5,6};
//This is the buffer that contains the bits for the LED display on
//a row-by-row order from the top row down. The bits 4-0 in each
//byte (row) correspond to the LED columns from left to right.
//byte led_buf[7] = {0x04,0x0A,0x11,0x1F,0x11,0x11,0x11};
byte led_buf[7] = {0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};


//              Column Bits
//               4 3 2 1 0
//              +-+-+-+-+-+
//      Row 0   |0|0|1|0|0|  -> 0x04
//              +-+-+-+-+-+
//      Row 1   |0|1|0|1|0|  -> 0x0A
//              +-+-+-+-+-+
//      Row 2   |1|0|0|0|1|  -> 0x11
//              +-+-+-+-+-+
//      Row 3   |1|1|1|1|1|  -> 0x1F
//              +-+-+-+-+-+
//      Row 4   |1|0|0|0|1|  -> 0x11
//              +-+-+-+-+-+
//      Row 5   |1|0|0|0|1|  -> 0x11
//              +-+-+-+-+-+
//      Row 6   |1|0|0|0|1|  -> 0x11
//              +-+-+-+-+-+

byte letters[12][7];
int currentLetter = 0, currentShift = 0;


//Letter A
byte led_buf2[7] = {0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E};

//Letter B
byte led_buf3[7] = {0x04,0x0A,0x11,0x1F,0x11,0x11,0x11};

//A global byte to keep track of the row being driven
//to the display. We will increment it each time we change
//to the next row but we will also mask (clear) the upper
//5 bits to make sure that we only ever get values 0-7.
byte theRow=0;

//This is the function that will be used to service our interrupt.
//It will drive to the display (paint) a new row each time it is
//called. It will be called when the interrupt is triggered by a signal
//on Int.0 (pin 2 on the UNO). We will drive Int.0 with a square wave
//generated by a call to the Arduino library function Tone. Tone will
//generate a continuous 'tone' in the form of a square wave on a pin.
//That pin will be connected to Int.o (pin 2). The interrupt will be
//called every time a positive-going edge is detected on the Int.o pin.
//The frequency of the tone will determine the duration of a row
//being displayed on the LED array.
void Paint()
{
  //This whole ISR takes just 33.6 uS to execute
  digitalWrite(row_array[theRow],HIGH);
  theRow++;
  if(theRow>=7)
    theRow=0;

  digitalWrite(col_array[0],led_buf[theRow]&0x10);
  digitalWrite(col_array[1],led_buf[theRow]&0x08);
  digitalWrite(col_array[2],led_buf[theRow]&0x04);
  digitalWrite(col_array[3],led_buf[theRow]&0x02);
  digitalWrite(col_array[4],led_buf[theRow]&0x01);

  digitalWrite(row_array[theRow],LOW);
}
  String str = "ENT";
  byte disp[3][7];
void setup() {

  pinMode(13,OUTPUT);

  //Setup the row pins (all are outputs)  
  for(int i=0;i<NUM_ROWS;i++)
  {
    pinMode(row_array[i],OUTPUT);
    digitalWrite(row_array[i],HIGH);
  }

  //Setup the row pins (all are outputs)
  for(int i=0;i<NUM_COLS;i++)
  {
    pinMode(col_array[i],OUTPUT);
    digitalWrite(col_array[i],HIGH);
  }
  

  for(int i = 0; i < str.length(); i++)
  {
    for(int j = 0; j < 7; j++)
      disp[i][j] = charmap[((int)str[i] - 32) * 8 + j];
  }
  //setup letters into array
  for(int i = 0; i < 7; i++)
  {
    letters[0][i] = charmap[37 * 8 + i];
    letters[1][i] = charmap[46 * 8 + i];
    letters[2][i] = charmap[52 * 8 + i];
    letters[3][i] = charmap[18 * 8 + i];
    letters[4][i] = charmap[19 * 8 + i];
    letters[5][i] = charmap[20 * 8 + i];
    letters[6][i] = charmap[48 * 8 + i];
    letters[7][i] = charmap[55 * 8 + i];
    letters[8][i] = charmap[46 * 8 + i];
    letters[9][i] = charmap[37 * 8 + i];
    letters[10][i] = charmap[36 * 8 + i];
    letters[11][i] = charmap[1 * 8 + i];
  }

//We will start always at row zero
  theRow=0;

//This call to attachInterrupt specifies the interrupt pin as well
//as the name of the function that will be called when the interrupt occurs.
//The last parameter is what causes the interrupt to be triggered. We will
//choose rising edge but we would get the same effect if we use falling edge.
  attachInterrupt(0,Paint,RISING);

//Generate the tone on a pin. It must be a pin that can generate a PWM sigal.
  tone(9,250);

}

void loop() {
  //All we do in loop() (in this example) is to wait 1 second and write a different
  //set of data to the LED buffer. We are only alternating between capital A and B
  //but this should serve as a good starting place to modifying this routine to handle
  //any letter as a 5X7 bitmap.
  //memcpy(led_buf,led_buf2,7);
  shift();
  delay(500);
  //memcpy(led_buf,led_buf3,7);
  //delay(1000);
}



void shift()
{
  for(int i = 0; i < 7; i++)
  {
    led_buf[i] = (led_buf[i] << 1);  
  }
  currentShift++;
  if(currentShift < 2)
    return;
  
  switch(currentShift)
  {
    case 3: for(int i = 0; i < 7; i++)
              if(letters[currentLetter][i] & 0x10)
                led_buf[i] |= 0x01;
            break;
    case 4: for(int i = 0; i < 7; i++)
              if(letters[currentLetter][i] & 0x08)
                led_buf[i] |= 0x01;
            break;
    case 5: for(int i = 0; i < 7; i++)
              if(letters[currentLetter][i] & 0x04)
                led_buf[i] |= 0x01;
            break;
    case 6: for(int i = 0; i < 7; i++)
              if(letters[currentLetter][i] & 0x02)
                led_buf[i] |= 0x01;
            break;
    case 7: for(int i = 0; i < 7; i++)
              if(letters[currentLetter][i] & 0x01)
                led_buf[i] |= 0x01;
            break;
  };
  if(currentShift >= 7)
  {
    currentShift = 0;
    if(currentLetter >= 11)
      currentLetter = 0;
    else
      currentLetter++;
  }
}


